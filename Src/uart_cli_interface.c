/*
 * uart_parse.c
 *
 *  Created on: 15-Oct-2018
 *      Author: medprime
 */

#include <uart_cli_interface.h>


extern UART_HandleTypeDef huart2;


/* Dimensions the buffer into which input characters are placed. */
#define cmdMAX_INPUT_SIZE 50

const char* pcNewLine = "\n";

const char* pcWelcomeMessage = "FREERTOS CLI Without FREERTOS Kernel.\r\n\r\nEnter 'help' to view a list of available commands.\r\n\r\n>";
const char* pcEndOfOutputMessage = "\r\n[Press ENTER to execute the previous command again]\r\n\r\n>";

/* DEL acts as a backspace. */
#define cmdASCII_DEL		( 0x7F )


void xSerialPutChar(UART_HandleTypeDef *huart, uint8_t pData)
    {
    huart->Instance->DR = (pData);
    while (__HAL_UART_GET_FLAG(huart,UART_FLAG_TC) == 0);
    }

void vSerialPutString(UART_HandleTypeDef *huart, uint8_t* pData, uint16_t Size)
    {
    while (Size--)
	{
	xSerialPutChar(huart, *pData++);
	}
    }

void UARTCommandConsoleLoop()
    {
    static uint8_t cRxedChar;
    static uint8_t ucInputIndex = 0;
    static char *pcOutputString;
    static char cInputString[cmdMAX_INPUT_SIZE];
    static char cLastInputString[cmdMAX_INPUT_SIZE];
    static BaseType_t xReturned;

    /* Obtain the address of the output buffer.  Note there is no mutual
     exclusion on this buffer as it is assumed only one command console interface
     will be used at any one time. */

    /* Send the welcome message. */
    static uint8_t first_flag = 0;
    if (first_flag == 0)
	{
	pcOutputString = FreeRTOS_CLIGetOutputBuffer();
	first_flag = 1;
	vSerialPutString(&huart2, (uint8_t* ) pcWelcomeMessage,
		(unsigned short ) strlen(pcWelcomeMessage));
	}

    if (Ring_Buffer_Get_Count() > 0)
	{
	Ring_Buffer_Get_Char(&cRxedChar);
	/* Echo the character back. */
	   //xSerialPutChar(&huart2, cRxedChar);
	/* Was it the end of the line? */
	if (cRxedChar == '\n')
	    {
	    /* Just to space the output from the input. */
	    //vSerialPutString(&huart2, (uint8_t * ) pcNewLine, (unsigned short ) strlen(pcNewLine));
	    /* See if the command is empty, indicating that the last command
	     is to be executed again. */
	    if (ucInputIndex == 0)
		{
		/* Copy the last command back into the input string. */
		strcpy(cInputString, cLastInputString);
		}

	    /* Pass the received command to the command interpreter.  The
	     command interpreter is called repeatedly until it returns
	     pdFALSE	(indicating there is no more output) as it might
	     generate more than one string. */
	    do
		{
		/* Get the next output string from the command interpreter. */
		xReturned = FreeRTOS_CLIProcessCommand(cInputString,
			pcOutputString, 256);

		/* Write the generated string to the UART. */
		vSerialPutString(&huart2, (uint8_t *) pcOutputString,
			(unsigned short) strlen(pcOutputString));

		}
	    while (xReturned != pdFALSE);

	    /* All the strings generated by the input command have been
	     sent.  Clear the input string ready to receive the next command.
	     Remember the command that was just processed first in case it is
	     to be processed again. */
	    strcpy(cLastInputString, cInputString);
	    ucInputIndex = 0;
	    memset(cInputString, 0x00, cmdMAX_INPUT_SIZE);

	    vSerialPutString(&huart2, (uint8_t *) pcEndOfOutputMessage,
		    (unsigned short) strlen(pcEndOfOutputMessage));
	    }
	else
	    {
	    if (cRxedChar == '\r')
		{
		/* Ignore the character. */
		}
	    else if ((cRxedChar == '\b') || (cRxedChar == cmdASCII_DEL))
		{
		/* Backspace was pressed.  Erase the last character in the
		 string - if any. */
		if (ucInputIndex > 0)
		    {
		    ucInputIndex--;
		    cInputString[ucInputIndex] = '\0';
		    }
		}
	    else
		{
		/* A character was entered.  Add it to the string entered so
		 far.  When a \n is entered the complete	string will be
		 passed to the command interpreter. */
		if ((cRxedChar >= ' ') && (cRxedChar <= '~'))
		    {
		    if (ucInputIndex < cmdMAX_INPUT_SIZE)
			{
			cInputString[ucInputIndex] = cRxedChar;
			ucInputIndex++;
			}
		    }
		}
	    }

	}
    }
